{% extends "base.html" %}

{% block title %}Strands Game{% endblock %}

{% block content %}
<article class="post">
    <header class="post-header">
        <h1 class="post-title">{{ title }}</h1>
        <hr />
    </header>

    <div class="post-content">
        <div class="game-container">
            <div class="game-info">
                <p>Find the theme words and the spangram. Theme words must be at least 3 letters long.</p>
                <div class="theme-info">
                    <div class="theme-hint">
                        <span>Theme: <span id="theme-hint">???</span></span>
                        <button id="hint-button" class="hint-button">Hint</button>
                    </div>
                    <div class="theme-progress">
                        <span>Theme Words: <span id="theme-words-found">0</span>/<span id="total-theme-words">0</span></span>
                    </div>
                </div>
                <div class="game-stats">
                    <span>Score: <span id="score">0</span></span>
                    <span>Words Found: <span id="words-found">0</span></span>
                </div>
                <div class="game-board" id="game-board"></div>
                <div class="selected-word" id="selected-word"></div>
                <div class="found-words" id="found-words"></div>
                <button id="new-game" class="play-button">New Game</button>
            </div>
        </div>
    </div>
</article>

<style>
/* Dark mode theme for Strands game */
.game-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    position: relative;
    background-color: #1a1a1a;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.game-info {
    text-align: center;
    margin-bottom: 20px;
    position: relative;
    color: #e0e0e0;
}

.game-info p {
    color: #b0b0b0;
    margin-bottom: 20px;
}

.theme-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 1rem 0;
    padding: 0.5rem 1rem;
    background-color: #2a2a2a;
    border-radius: 4px;
}

.theme-hint {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.theme-progress {
    font-weight: bold;
}

.hint-button {
    padding: 5px 10px;
    background-color: #3fa757;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.hint-button:hover {
    background-color: #2d7a41;
    transform: translateY(-2px);
}

.game-stats {
    display: flex;
    justify-content: center;
    gap: 2rem;
    margin: 1rem 0;
    font-size: 1.2em;
}

.game-board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 2px;
    margin: 20px auto;
    max-width: 400px;
    background: #2a2a2a;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.letter {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #333;
    border: 1px solid #444;
    border-radius: 4px;
    font-size: 1.5em;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
    color: #e0e0e0;
}

.letter.selected {
    background: #3fa757;
    color: white;
    border-color: #2d7a41;
    box-shadow: 0 0 5px rgba(63, 167, 87, 0.5);
}

.letter.used {
    background: #222;
    color: #666;
    cursor: not-allowed;
}

.letter.theme {
    background: #4a4a4a;
    border-color: #5a5a5a;
}

.letter.spangram {
    background: #4a4a4a;
    border-color: #5a5a5a;
    font-weight: bold;
}

.selected-word {
    margin: 20px 0;
    font-size: 1.5em;
    min-height: 1.5em;
    color: #e0e0e0;
}

.found-words {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin: 20px 0;
    min-height: 100px;
}

.word-tag {
    background: #333;
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 0.9em;
    color: #e0e0e0;
}

.word-tag.theme {
    background: #3fa757;
    color: white;
}

.word-tag.spangram {
    background: #4a4a4a;
    color: white;
    font-weight: bold;
}

.play-button {
    padding: 10px 20px;
    font-size: 1.2em;
    background-color: #3fa757;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.play-button:hover {
    background-color: #2d7a41;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}
</style>

<script>
const BOARD_SIZE = 8;
const MIN_WORD_LENGTH = 3;

// Game themes with their associated words
const GAME_THEMES = [
    {
        theme: "PROGRAMMING",
        words: ["PYTHON", "JAVA", "CODE", "DATA", "WEB", "API", "HTML", "CSS", "SQL", "JSON", "REST", "GIT", "CLOUD", "SERVER", "CLIENT", "DEBUG", "TEST", "BUILD", "DEPLOY", "SCALE", "SECURE"],
        spangram: "PROGRAMMING"
    },
    {
        theme: "COMPUTER",
        words: ["CPU", "RAM", "DISK", "SCREEN", "KEYBOARD", "MOUSE", "PRINTER", "SCANNER", "MONITOR", "LAPTOP", "DESKTOP", "TABLET", "PHONE", "WIFI", "BLUETOOTH", "USB", "HDMI", "ETHERNET", "CABLE", "PLUG", "SOCKET"],
        spangram: "COMPUTER"
    },
    {
        theme: "INTERNET",
        words: ["WEB", "SITE", "PAGE", "LINK", "URL", "DOMAIN", "SERVER", "CLIENT", "BROWSER", "SEARCH", "EMAIL", "CHAT", "BLOG", "POST", "TWEET", "LIKE", "SHARE", "DOWNLOAD", "UPLOAD", "STREAM", "BUFFER"],
        spangram: "INTERNET"
    },
    {
        theme: "DATABASE",
        words: ["TABLE", "ROW", "COLUMN", "QUERY", "INDEX", "KEY", "JOIN", "SELECT", "INSERT", "UPDATE", "DELETE", "SCHEMA", "VIEW", "TRIGGER", "STORE", "CACHE", "BACKUP", "RESTORE", "MIGRATE", "SYNC", "REPLICA"],
        spangram: "DATABASE"
    },
    {
        theme: "ALGORITHM",
        words: ["SORT", "SEARCH", "FILTER", "MAP", "REDUCE", "LOOP", "RECURSE", "STACK", "QUEUE", "HEAP", "TREE", "GRAPH", "ARRAY", "LIST", "HASH", "BINARY", "MERGE", "QUICK", "BUBBLE", "INSERT", "SELECT"],
        spangram: "ALGORITHM"
    }
];

let board = [];
let selectedLetters = [];
let foundWords = new Set();
let themeWords = new Set();
let spangram = "";
let currentTheme = null;
let score = 0;
let gameOver = false;
let hintsUsed = 0;

function createBoard() {
    // Select a random theme
    currentTheme = GAME_THEMES[Math.floor(Math.random() * GAME_THEMES.length)];
    
    // Initialize board with random letters
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    board = [];
    for (let i = 0; i < BOARD_SIZE; i++) {
        board[i] = [];
        for (let j = 0; j < BOARD_SIZE; j++) {
            board[i][j] = {
                letter: letters[Math.floor(Math.random() * letters.length)],
                isTheme: false,
                isSpangram: false
            };
        }
    }
    
    // Place theme words on the board
    placeThemeWords();
    
    // Update theme hint
    document.getElementById('theme-hint').textContent = currentTheme.theme;
    document.getElementById('total-theme-words').textContent = currentTheme.words.length;
}

function placeThemeWords() {
    // Place the spangram first
    placeWord(currentTheme.spangram, true);
    
    // Then place other theme words
    currentTheme.words.forEach(word => {
        placeWord(word, false);
    });
}

function placeWord(word, isSpangram) {
    const directions = [
        { row: 0, col: 1 },   // right
        { row: 1, col: 0 },   // down
        { row: 1, col: 1 },   // diagonal down-right
        { row: 1, col: -1 },  // diagonal down-left
        { row: 0, col: -1 },  // left
        { row: -1, col: 0 },  // up
        { row: -1, col: -1 }, // diagonal up-left
        { row: -1, col: 1 }   // diagonal up-right
    ];
    
    // Try to place the word in a random position and direction
    const maxAttempts = 100;
    let attempts = 0;
    let placed = false;
    
    while (attempts < maxAttempts && !placed) {
        const startRow = Math.floor(Math.random() * BOARD_SIZE);
        const startCol = Math.floor(Math.random() * BOARD_SIZE);
        const direction = directions[Math.floor(Math.random() * directions.length)];
        
        // Check if the word fits in this direction
        let fits = true;
        for (let i = 0; i < word.length; i++) {
            const row = startRow + i * direction.row;
            const col = startCol + i * direction.col;
            
            if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                fits = false;
                break;
            }
        }
        
        if (fits) {
            // Place the word
            for (let i = 0; i < word.length; i++) {
                const row = startRow + i * direction.row;
                const col = startCol + i * direction.col;
                
                board[row][col].letter = word[i];
                board[row][col].isTheme = true;
                if (isSpangram) {
                    board[row][col].isSpangram = true;
                }
            }
            placed = true;
        }
        
        attempts++;
    }
}

function renderBoard() {
    const gameBoard = document.getElementById('game-board');
    gameBoard.innerHTML = '';
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            const letter = document.createElement('div');
            letter.className = 'letter';
            letter.textContent = board[i][j].letter;
            letter.dataset.row = i;
            letter.dataset.col = j;
            
            if (board[i][j].isTheme) {
                letter.classList.add('theme');
            }
            
            if (board[i][j].isSpangram) {
                letter.classList.add('spangram');
            }
            
            if (selectedLetters.some(pos => pos.row === i && pos.col === j)) {
                letter.classList.add('selected');
            }
            
            if (foundWords.has(board[i][j].letter)) {
                letter.classList.add('used');
            }
            
            letter.addEventListener('click', () => handleLetterClick(i, j));
            gameBoard.appendChild(letter);
        }
    }
}

function handleLetterClick(row, col) {
    if (gameOver) return;
    
    const letter = board[row][col].letter;
    const pos = { row, col, letter };
    
    if (selectedLetters.length === 0) {
        selectedLetters.push(pos);
        updateSelectedWord();
        renderBoard();
    } else {
        const lastPos = selectedLetters[selectedLetters.length - 1];
        if (isAdjacent(lastPos, pos) && !selectedLetters.some(p => p.row === row && p.col === col)) {
            selectedLetters.push(pos);
            updateSelectedWord();
            renderBoard();
            
            const word = getSelectedWord();
            if (word.length >= MIN_WORD_LENGTH) {
                // Check if it's a theme word
                if (currentTheme.words.includes(word) && !themeWords.has(word)) {
                    themeWords.add(word);
                    score += word.length * 2; // Theme words are worth double points
                    updateScore();
                    updateFoundWords();
                    checkWinCondition();
                } 
                // Check if it's the spangram
                else if (word === currentTheme.spangram && !foundWords.has(word)) {
                    foundWords.add(word);
                    score += word.length * 3; // Spangram is worth triple points
                    updateScore();
                    updateFoundWords();
                    checkWinCondition();
                }
                // Check if it's a valid word (not already found)
                else if (!foundWords.has(word)) {
                    foundWords.add(word);
                    score += word.length;
                    updateScore();
                    updateFoundWords();
                }
            }
        }
    }
}

function isAdjacent(pos1, pos2) {
    const rowDiff = Math.abs(pos1.row - pos2.row);
    const colDiff = Math.abs(pos1.col - pos2.col);
    return rowDiff <= 1 && colDiff <= 1 && !(rowDiff === 0 && colDiff === 0);
}

function getSelectedWord() {
    return selectedLetters.map(pos => pos.letter).join('');
}

function updateSelectedWord() {
    const word = getSelectedWord();
    document.getElementById('selected-word').textContent = word;
}

function updateScore() {
    document.getElementById('score').textContent = score;
    document.getElementById('words-found').textContent = foundWords.size;
    document.getElementById('theme-words-found').textContent = themeWords.size;
}

function updateFoundWords() {
    const foundWordsDiv = document.getElementById('found-words');
    foundWordsDiv.innerHTML = '';
    
    // First display theme words
    Array.from(themeWords).sort().forEach(word => {
        const wordTag = document.createElement('span');
        wordTag.className = 'word-tag theme';
        wordTag.textContent = word;
        foundWordsDiv.appendChild(wordTag);
    });
    
    // Then display the spangram if found
    if (foundWords.has(currentTheme.spangram)) {
        const spangramTag = document.createElement('span');
        spangramTag.className = 'word-tag spangram';
        spangramTag.textContent = currentTheme.spangram;
        foundWordsDiv.appendChild(spangramTag);
    }
    
    // Then display other found words
    Array.from(foundWords)
        .filter(word => !themeWords.has(word) && word !== currentTheme.spangram)
        .sort()
        .forEach(word => {
            const wordTag = document.createElement('span');
            wordTag.className = 'word-tag';
            wordTag.textContent = word;
            foundWordsDiv.appendChild(wordTag);
        });
}

function checkWinCondition() {
    if (themeWords.size === currentTheme.words.length && foundWords.has(currentTheme.spangram)) {
        gameOver = true;
        document.getElementById('game-status').textContent = 'Congratulations! You found all theme words and the spangram!';
    }
}

function showHint() {
    if (hintsUsed < 3) {
        hintsUsed++;
        
        // Find a theme word that hasn't been found yet
        const unfoundThemeWords = currentTheme.words.filter(word => !themeWords.has(word));
        
        if (unfoundThemeWords.length > 0) {
            const hintWord = unfoundThemeWords[Math.floor(Math.random() * unfoundThemeWords.length)];
            
            // Find the position of the hint word on the board
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j].letter === hintWord[0] && board[i][j].isTheme) {
                        // Highlight the first letter of the hint word
                        const letterElement = document.querySelector(`.letter[data-row="${i}"][data-col="${j}"]`);
                        if (letterElement) {
                            letterElement.style.animation = 'pulse 1s infinite';
                        }
                        return;
                    }
                }
            }
        }
    }
}

// Add CSS animation for the hint pulse
const style = document.createElement('style');
style.textContent = `
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(63, 167, 87, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(63, 167, 87, 0); }
        100% { box-shadow: 0 0 0 0 rgba(63, 167, 87, 0); }
    }
`;
document.head.appendChild(style);

function initGame() {
    selectedLetters = [];
    foundWords.clear();
    themeWords.clear();
    score = 0;
    gameOver = false;
    hintsUsed = 0;
    createBoard();
    renderBoard();
    updateSelectedWord();
    updateScore();
    updateFoundWords();
}

document.getElementById('new-game').addEventListener('click', initGame);
document.getElementById('hint-button').addEventListener('click', showHint);

// Initialize the game
initGame();
</script>
{% endblock %} 